#!/usr/bin/python

"""
joyq performs query operations on JSON-formatted flow objects; see joyq --help for more details
"""

"""
 *
 * Copyright (c) 2017 Cisco Systems, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 *   Redistributions in binary form must reproduce the above
 *   copyright notice, this list of conditions and the following
 *   disclaimer in the documentation and/or other materials provided
 *   with the distribution.
 *
 *   Neither the name of the Cisco Systems, Inc. nor the names of its
 *   contributors may be used to endorse or promote products derived
 *   from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
"""

import sys, json, operator, gzip, string, time, pprint, copy, re, pickle, collections, fnmatch
import os
import subprocess
import atexit
from optparse import OptionParser
from math import sqrt, log


# flow iterator classes
#
class flowIterator:
   def __init__(self):
      pass

   def __iter__(self):
      return self

   def next(self):
      flow = dict()
      return flow


class flowIteratorFromFile(flowIterator):
   """
   Create a new flowIterator instance from the given input file.
   This allows iteration over all JSON objects within the file.
   If the file given is a PCAP, it will first be run through Joy
   in order to generate the necessary JSON output for use here.
   """
   def __init__(self, f):
      self.badLineCount = 0
      self.lineCount = 0
      self.pcap_loader = PcapLoader(file=f)

      if f is '-':
         self.f = sys.stdin
      else:
         if ".gz" in f:
            self.f = gzip.open(f,'r')
         elif self.pcap_loader.is_pcap():
            # Run Joy to generate some JSON for use in this script.
            self.pcap_loader.run()
            # Open the json file that was just made.
            self.f = gzip.open(self.pcap_loader.temp_json['file'], 'r')
         else:
            self.f = open(f,'r')

   def next(self):
      while True:
         try:
            line = self.f.readline()
            if line == '':
               raise StopIteration
            tmp = json.loads(line)
            if 'version' not in tmp:
               self.lineCount += 1
               return tmp
         except StopIteration:
            sys.stderr.write("read " + str(self.lineCount) + " lines\n")
            if self.badLineCount > 0:
               sys.stderr.write("warning: could not parse " + str(self.badLineCount) + " lines\n")
            self.pcap_loader.cleanup()
            raise
         except:
            self.badLineCount += 1
            # sys.stderr.write('error: could not read line: ' + line)

class flowFilterIterator(flowIterator):
   def __init__(self, source, filter):
      self.source = source
      self.filter = filter

   def next(self):
      tmp = self.source.next()
      while self.filter.match(tmp) is not True:
         tmp = self.source.next()
      return tmp

class flowStitchIterator(flowIterator):
   def __init__(self, source):
      self.source = source
      self.active_flows = collections.OrderedDict()
   
      for f in source:
         key = (f['sa'], f['da'], f['sp'], f['dp'], f['pr'])
         revkey = (f['da'], f['sa'], f['dp'], f['sp'], f['pr'])
         if key in self.active_flows:
            self.active_flows[key] = self.merge(self.active_flows[key], f)
            pass
         elif revkey in self.active_flows:
            self.active_flows[revkey] = self.merge_reverse(self.active_flows[revkey], f)
            pass
         else:
            self.active_flows[key] = f

      self.flows = iter(self.active_flows.values())

   def next(self):
      return self.flows.next()

   # merge f2 into f1, where both flows are in the same direction, and
   # f1 preceeds f2 (f1.ts < f2.ts)
   #
   def merge(self, f1, f2):
      for k, v in f2.items():
         if k not in f1:
            f1[k] = f2[k]
         else:
            if k == 'te': 
               f1[k] = max(f1[k],f2[k])
            elif k == 'ip' or k == 'ib':
               f1[k] += f2[k]
            elif k == 'op' or k == 'ob':
               f1[k] += f2[k]
            elif k == 'bd':
               for i, e in enumerate(f2[k]):
                  f1[k][i] += e
            else:
               pass
         return f1

   # merge f2 into f1, where f2 is in the reverse direction to f1, and
   # f1 preceeds f2 (f1.ts < f2.ts)
   #
   def merge_reverse(self, f1, f2):
      for k, v in f2.items():
         if k not in f1:
            if k == 'op':
               f1['ip'] += f2[k]
            elif k == 'ob':
               f1['ib'] += f2[k]
            else:
               f1[k] = f2[k]
         else:
            if k == 'te':
               f1[k] = max(f1[k],f2[k])
            elif k == 'ip':
               f1[k] += f2['ob']
            elif k == 'op':
               f1[k] += f2['ib']
            elif k == 'bd':
               for i, e in enumerate(f2[k]):
                  f1[k][i] += e
            else:
               pass
         return f1

class flowEnrichIterator(flowIterator):
   def __init__(self, source, name, function):
      self.source = source
      self.name = name
      self.function = function

   def next(self):
      nextval = self.source.next()
      tmp = self.function(nextval)
      if tmp: 
         nextval[self.name] = tmp
      return nextval

# flow processor classes
#
class flowProcessor:
   def __init__(self, indent=None):
      self.flowset = []
      self.indent = indent

   def processFlow(self, flow):
      self.flowset.append(flow)

   def preProcess(self, context=None):    
      self.context = context

   def postProcess(self, proc=None):    
      for flow in self.flowset:
         json.dump(flow, sys.stdout, indent=self.indent)
         print ""

class splitProcessor(flowProcessor):
   def __init__(self, fpobj, field):
      self.fpobj = fpobj
      self.dict = dict()
      self.field = field
      self.template = templateDict(field)
      # print "field: " + str(field)

   def processFlow(self, flow):
      value = pickle.dumps(self.template.copySelectedElements(self.template.template, flow))
      # flow['value'] = value
      if value not in self.dict:
         self.dict[value] = copy.deepcopy(self.fpobj)
         self.dict[value].preProcess([self.field, value])
      self.dict[value].processFlow(flow)

   def postProcess(self, proc=None):
      if self.context:
         print self.context
      for k, v in self.dict.items():
         v.postProcess(copy.deepcopy(proc))

class flowStitchProcessor:
   def __init__(self, fp):
      self.flowset = []
      self.active_flows = dict()
      self.fp

   def processFlow(self, flow):
      if 'x' in flow and flow['x'] == 'a':
         pass
         # print "found active timeout"
      self.flowset.append(flow)

   def postProcess(self, proc=None):    
      for flow in self.flowset:
         json.dump(flow, sys.stdout)
         print ""

class templateDict:
   def __init__(self, elements):
      whitespace_pattern = re.compile(r'\s+')
      elements = re.sub(whitespace_pattern, '', elements)
      self.template = self.string_to_template_object(elements)

   def string_to_template_object(self, s):
      t = '{'
      needArg = False
      for x in re.split('([\{\}\[\],])', s):         
         if x == '':
            pass
         elif x == '{' or x == '[':
            t += x
            needArg = False
         elif x == '}' or x == ']' or x == ',':
            if needArg:
               t += "None"
               needArg = False
            t += x
         else:
            t += '\"' + x + '\":'
            needArg = True
      if needArg:
         t += "None"
      t += '}'
      # print "t: " + t
      return eval(t)
      
   def copySelectedElements(self, tmplDict, flow):
      outDict = dict()
      for k, v in tmplDict.items():
         if k in flow:
            if isinstance(v, list):
               flowList = flow[k]
               if flowList:
                  outDict[k] = list()
                  for x in flowList:
                     for y in v:
                        tmp = self.copySelectedElements(y, x)
                        if tmp:
                           outDict[k].append(tmp)
                  if not outDict[k]:
                     outDict = {}
            elif isinstance(v, dict):
               tmp = self.copySelectedElements(v, flow[k])
               if tmp:
                  outDict[k] = tmp
            else:
               if v:
                  if flow[k] == v:
                     outDict[k] = flow[k]
               else:
                  outDict[k] = flow[k]
      if outDict:
         return outDict
      else:
         return None

   def getSelectedElement(self, tmplDict, flow):
      outDict = dict()
      for k, v in tmplDict.items():
         if k in flow:
            if isinstance(v, list):
               flowList = flow[k]
               if flowList:
                  outDict[k] = list()
                  for x in flowList:
                     for y in v:
                        tmp = self.getSelectedElement(y, x)
                        if tmp:
                           outDict[k].append(tmp)
                  if not outDict[k]:
                     outDict = {}
            elif isinstance(v, dict):
               tmp = self.getSelectedElement(v, flow[k])
               if tmp:
                  outDict[k] = tmp
            else:
               if v:
                  if flow[k] == v:
                     outDict[k] = flow[k]
               else:
                  outDict[k] = flow[k]
      if outDict:
         return outDict
      else:
         return None

   
class flowElementSelector(flowProcessor):

   def __init__(self, elements):
      self.flowset = []
      self.template = templateDict(elements)
      
   def processFlow(self, flow):
      output = self.template.copySelectedElements(self.template.template, flow)
      if output:
         self.flowset.append(output)

   def postProcess(self, proc=flowProcessor()):    
      proc.preProcess(self.context)
      for flow in self.flowset:
         proc.processFlow(flow)
      proc.postProcess()
     
class flowProcessorDistribution(flowProcessor):
   def __init__(self):
      self.dist = dict()
      self.total = 0

   def processFlow(self, flow):
      value = pickle.dumps(flow)
      self.key = tuple(flow.keys())
      if value in self.dist:
         self.dist[value] += 1
      else:
         self.dist[value] = 1
      self.total += 1

   def postProcess(self):    
      output = list()
      for k, v in self.dist.iteritems():
         d = pickle.loads(k)
         d["count"] = v   
         d["total"] = self.total   
         # d["fraction"] = v/self.total   
         output.append(d)
      output.sort(key=lambda x: x["count"], reverse=True)
      for d in output:
         json.dump(d, sys.stdout)
         print ""

class flowProcessorSum(flowProcessor):
   def __init__(self, sumvars, indent=None):
      self.sums = dict()
      self.fixed_fields = dict()
      self.total = 0
      self.sumvars = sumvars
      self.indent = indent

   def processFlow(self, flow):
      self.key = tuple(flow.keys())
      for k, v in flow.iteritems():
         if k in self.sumvars: # assume isinstance(v, int):
            if k in self.sums:
               self.sums[k] += v
            else:
               self.sums[k] = 0
         else:
            if k not in self.fixed_fields:
               self.fixed_fields[k] = set()
            self.fixed_fields[k].add(v)
      self.total += 1

   def postProcess(self):    
      d = dict()
      for k, v in self.fixed_fields.iteritems():
         if len(v) == 1:
            d[k] = list(v)[0]
         else:
            d[k] = list(v)
      for k, v in self.sums.iteritems():
         klist = list(k)
         for i, x in enumerate(list(self.key)):
            if x in self.sums:
               d[x] = self.sums[x]
      # NOTE: sum_over might interfere with --dist
      d["sum_over"] = self.total   
      json.dump(d, sys.stdout, indent=self.indent)   
      print ""

# fnmatch 
# *	  matches everything
# ?       matches any single character
# [seq]	  matches any character in seq       *** DOES NOT WORK YET ***
# [!seq]  matches any character not in seq   *** DOES NOT WORK YET ***

class simplePredicate:

   def __init__(self, elements):
      self.flowset = []
      if elements:
         tokens = re.split('([=<>~])', elements)
         self.template = templateDict(tokens[0]) 
         self.op = tokens[1]
         self.arg = tokens[2]

         if self.arg.isdigit():
            self.arg = int(self.arg)
         else:
            try:
                self.arg = float(self.arg)
            except:
                pass

         self.matchAll = False
      else:
         self.matchAll = True

   def eval(self, flow):
      # print 'flow: ' + str(flow)
      # print 'op: ' + str(self.op)
      # print 'arg: ' + str(self.arg)

      # if flow is list, match any element in it
      if isinstance(flow, list):
         listMatch = False
         if flow:
            for x in flow:
               x = x.values()[0]
               if self.eval(x):
                  listMatch = True
         return listMatch
      elif isinstance(flow, dict):
         # print 'dict flow: ' + str(flow)
         x = flow.values()[0]
         return self.eval(x)
      
      if self.op == '=':
         if self.arg == '*':
            return True
         elif isinstance(self.arg, int):
            return self.arg == flow
         else:
            #print '------------------'
            #print 'flow: ' + str(flow)
            #print 'arg:  ' + str(self.arg)
            return fnmatch.fnmatch(flow, self.arg)
      elif self.op == '~':
         if self.arg == '*':
            return False
         elif isinstance(self.arg, int):
            return self.arg != flow
         else:
            return not fnmatch.fnmatch(flow, self.arg)
      elif self.op == '>':
         return flow > self.arg
      elif self.op == '<':
         return flow < self.arg

   def match(self, flow):
      if self.matchAll is True:
         return True         
      else:
         output = self.template.getSelectedElement(self.template.template, flow)
         if output:
            return self.eval(output.values()[0])
         else:
            if self.op == '~' and self.arg == '*':
               return True  # true since element is absent from flow
            return False


class andFilter:
   def __init__(self, L, R):
      self.L = L
      self.R = R

   def match(self, flow):
      return (self.L.match(flow) & self.R.match(flow))

class orFilter:
   def __init__(self, L, R):
      self.L = L
      self.R = R

   def match(self, flow):
      return (self.L.match(flow) | self.R.match(flow))

def predicate_from_postfix(tokenList):
   #print 'postfix: ' + str(tokenList)

   stack = list()
   for t in tokenList:
      # print t
      if t == ',':
         if len(stack) > 1:
            stack.append(andFilter(stack.pop(), stack.pop()))
      elif t == '|':
         if len(stack) > 1:
            stack.append(orFilter(stack.pop(), stack.pop()))
      else:
         stack.append(simplePredicate(t))   
   return stack.pop()

def infix_to_postfix(s):
   # operator precedence 
   prec = { '|': 3, ',': 2, '(': 1 }
    
   s = s.replace(' ', '')    # remove whitespace from input string
   # print 'infix: ' + str(s)
   
   # tokenize s into operators (',' or '|') and predicates, then
   # convert token list to postfix output 
   # 
   stack = list()
   output = []
   for t in re.findall("[\w><=~.*\{\}\[\]?\-+]+|[\(,|\)]", s):
      if '>' in t or '<' in t or '=' in t or '~' in t: 
         output.append(t)
      elif t == '(':
         stack.append(t)
      elif t == ')':
         topToken = stack.pop()
         while topToken != '(':
            output.append(topToken)
            topToken = stack.pop()
      else:
         while (not stack == []) and (prec[stack[-1]] >= prec[t]):
            output.append(stack.pop())
         stack.append(t)
   while stack != []:
      output.append(stack.pop())
   return output
      
         
class flowPredicate:
   def __init__(self, pred):
      if pred:
         self.pred = predicate_from_postfix(infix_to_postfix(pred))
      else:
         self.pred = None

   def match(self, flow):
      if self.pred:
         return self.pred.match(flow)
      else:
         return True
      

# command line processing (not yet utilized)
#
commands = { 
   "--from":   { 'needArg': True  },
   "--where":  { 'needArg': True  },
   "--select": { 'needArg': True  },
   "--split":  { 'needArg': True  },
   "--dist":   { 'needArg': False },
   "--sum":    { 'needArg': True  },
   "--stitch": { 'needArg': False }
}

def process_commands(command_string):
   needArg = False
   for a in command_string[1:]:
      print ">   " + a
      if a in commands:
         if needArg:
            print "error: command " + cmnd + " needs an argument"
            sys.exit()
         else:
            if not commands[a]['needArg']:
               print "executing " + a
            else:
               needArg = True
               cmnd = a
      else:
         if not needArg:
            print "error: argument " + a + " not proceeded by a command" 
            sys.exit()
         else:
            print "executing " + cmnd + " " + a
            needArg = False
            cmnd = None


class PcapLoader:
   """
   Helper to operate on PCAP files directly
   """
   def __init__(self, file):
      self.file = file
      self.temp_json = {'file': None, 'created': False}

   def cleanup(self):
      """
      Delete the temporary JSON file that was created.
      :return:
      """
      if self.temp_json['created'] is True:
         try:
            os.remove(self.temp_json['file'])
         except OSError:
            pass

   def is_pcap(self):
      """
      Determine whether a file is pcap.
      :return: True if pcap file, False otherwise
      """
      if self.file.endswith('.pcap'):
         return True
      else:
         # Look inside the file and check for pcap magic number
         if sys.byteorder == 'little':
            magic_number = bytearray.fromhex('d4 c3 b2 a1')
         else:
            magic_number = bytearray.fromhex('a1 b2 c3 d4')

         with open(self.file, 'rb') as f:
            ba = bytearray(f.readline())

            if ba[:4] == magic_number:
               return True
            else:
               return False

   def run(self):
      """
      Run Joy with the pcap file as input.
      The json output will then be operated upon in this program (joyq).
      A temporary json file (temp-joyq.json.gz) will be written to the user's "home" directory.
      Use the function cleanup() within this class to delete the file before program exit.
      :return:
      """
      cur_dir = os.path.dirname(__file__)
      temp_json_dir = os.path.expanduser('~')
      temp_json_filename = 'temp-joyq.json.gz'
      self.temp_json['file'] = os.path.join(temp_json_dir, temp_json_filename)

      enabled_features = ['bidir=1', 'http=1', 'tls=1', 'dns=1',
                          'ssh=1', 'ppi=1', 'entropy=1']

      # Construct the commands
      command = ['joy', 'outdir=' + temp_json_dir, 'output=' + temp_json_filename]
      command += enabled_features
      command.append(os.path.join(cur_dir, self.file))

      command_local = copy.deepcopy(command)
      command_local[0] = './joy'

      command_source = copy.deepcopy(command)
      command_source[0] = './bin/joy'

      try:
         subprocess.call(command)
      except OSError as e:
         if e.errno == os.errno.ENOENT:
            # Look within the same directory where joyq lives.
            try:
               subprocess.call(command_local)
            except OSError as ee:
               if ee.errno == os.errno.ENOENT:
                  # Look in typical source location
                  try:
                     subprocess.call(command_source)
                  except OSError as eee:
                     if eee.errno == os.errno.ENOENT:
                        print('\033[91m' + 'error: could not locate "joy" executable. exiting.' + '\033[0m')
                        sys.exit(1)
               else:
                  raise
         else:
            raise

      # Set flag indicating the temporary JSON file was made.
      self.temp_json['created'] = True


# TLS flow enrichment functions
#
# from tlsseclevel import tls_seclevel

tls_params = {
  "c005": {
    "hash": "SHA",
    "enc": "AES_256_CBC",
    "sig": "ECDSA",
    "auth": "HMAC",
    "kex": "ECDH"
  },
  "c004": {
    "hash": "SHA",
    "enc": "AES_128_CBC",
    "sig": "ECDSA",
    "auth": "HMAC",
    "kex": "ECDH"
  },
  "c007": {
    "hash": "SHA",
    "enc": "RC4_128",
    "sig": "ECDSA",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c006": {
    "hash": "SHA",
    "enc": "NULL",
    "sig": "ECDSA",
    "auth": "NULL",
    "kex": "ECDHE"
  },
  "0039": {
    "hash": "SHA",
    "enc": "AES_256_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "0038": {
    "hash": "SHA",
    "enc": "AES_256_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "c003": {
    "hash": "SHA",
    "enc": "3DES_EDE_CBC",
    "sig": "ECDSA",
    "auth": "HMAC",
    "kex": "ECDH"
  },
  "c002": {
    "hash": "SHA",
    "enc": "RC4_128",
    "sig": "ECDSA",
    "auth": "HMAC",
    "kex": "ECDH"
  },
  "0035": {
    "hash": "SHA",
    "enc": "AES_256_CBC",
    "sig": "RSA-KT",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "0034": {
    "hash": "SHA",
    "enc": "AES_128_CBC",
    "sig": "anon",
    "auth": "HMAC",
    "kex": "DH_anon"
  },
  "0037": {
    "hash": "SHA",
    "enc": "AES_256_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DH"
  },
  "0036": {
    "hash": "SHA",
    "enc": "AES_256_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DH"
  },
  "0031": {
    "hash": "SHA",
    "enc": "AES_128_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DH"
  },
  "0030": {
    "hash": "SHA",
    "enc": "AES_128_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DH"
  },
  "0033": {
    "hash": "SHA",
    "enc": "AES_128_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "0032": {
    "hash": "SHA",
    "enc": "AES_128_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "c04a": {
    "hash": "SHA256",
    "enc": "ARIA_128_CBC",
    "sig": "ECDSA",
    "auth": "HMAC",
    "kex": "ECDH"
  },
  "c07b": {
    "hash": "SHA384",
    "enc": "CAMELLIA_256_GCM",
    "sig": "RSA-KT",
    "auth": "CAMELLIA_256_GCM",
    "kex": "RSA"
  },
  "c07c": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_GCM",
    "sig": "RSA",
    "auth": "CAMELLIA_128_GCM",
    "kex": "DHE"
  },
  "c07d": {
    "hash": "SHA384",
    "enc": "CAMELLIA_256_GCM",
    "sig": "RSA",
    "auth": "CAMELLIA_256_GCM",
    "kex": "DHE"
  },
  "c07e": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_GCM",
    "sig": "RSA",
    "auth": "CAMELLIA_128_GCM",
    "kex": "DH"
  },
  "c07f": {
    "hash": "SHA384",
    "enc": "CAMELLIA_256_GCM",
    "sig": "RSA",
    "auth": "CAMELLIA_256_GCM",
    "kex": "DH"
  },
  "c001": {
    "hash": "SHA",
    "enc": "NULL",
    "sig": "ECDSA",
    "auth": "NULL",
    "kex": "ECDH"
  },
  "c0a7": {
    "hash": "SHA",
    "enc": "AES_256_CCM",
    "sig": "PSK",
    "auth": "AES_256_CCM",
    "kex": "DHE_PSK"
  },
  "cca9": {
    "hash": "SHA256",
    "enc": "CHACHA20_POLY1305",
    "sig": "ECDSA",
    "auth": "CHACHA20_POLY1305",
    "kex": "ECDHE"
  },
  "c04c": {
    "hash": "SHA256",
    "enc": "ARIA_128_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c0a4": {
    "hash": "SHA",
    "enc": "AES_128_CCM",
    "sig": "PSK",
    "auth": "AES_128_CCM",
    "kex": "PSK"
  },
  "c037": {
    "hash": "SHA256",
    "enc": "AES_128_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c089": {
    "hash": "SHA384",
    "enc": "CAMELLIA_256_GCM",
    "sig": "ECDSA",
    "auth": "CAMELLIA_256_GCM",
    "kex": "ECDH"
  },
  "c088": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_GCM",
    "sig": "ECDSA",
    "auth": "CAMELLIA_128_GCM",
    "kex": "ECDH"
  },
  "c09c": {
    "hash": "SHA",
    "enc": "AES_128_CCM",
    "sig": "RSA-KT",
    "auth": "AES_128_CCM",
    "kex": "RSA"
  },
  "c085": {
    "hash": "SHA384",
    "enc": "CAMELLIA_256_GCM",
    "sig": "anon",
    "auth": "CAMELLIA_256_GCM",
    "kex": "DH_anon"
  },
  "c04e": {
    "hash": "SHA256",
    "enc": "ARIA_128_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "ECDH"
  },
  "c087": {
    "hash": "SHA384",
    "enc": "CAMELLIA_256_GCM",
    "sig": "ECDSA",
    "auth": "CAMELLIA_256_GCM",
    "kex": "ECDHE"
  },
  "c086": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_GCM",
    "sig": "ECDSA",
    "auth": "CAMELLIA_128_GCM",
    "kex": "ECDHE"
  },
  "c081": {
    "hash": "SHA384",
    "enc": "CAMELLIA_256_GCM",
    "sig": "DSS",
    "auth": "CAMELLIA_256_GCM",
    "kex": "DHE"
  },
  "c080": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_GCM",
    "sig": "DSS",
    "auth": "CAMELLIA_128_GCM",
    "kex": "DHE"
  },
  "c083": {
    "hash": "SHA384",
    "enc": "CAMELLIA_256_GCM",
    "sig": "DSS",
    "auth": "CAMELLIA_256_GCM",
    "kex": "DH"
  },
  "c04d": {
    "hash": "SHA384",
    "enc": "ARIA_256_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c041": {
    "hash": "SHA384",
    "enc": "ARIA_256_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DH"
  },
  "c040": {
    "hash": "SHA256",
    "enc": "ARIA_128_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DH"
  },
  "c09f": {
    "hash": "SHA",
    "enc": "AES_256_CCM",
    "sig": "RSA",
    "auth": "AES_256_CCM",
    "kex": "DHE"
  },
  "c04f": {
    "hash": "SHA384",
    "enc": "ARIA_256_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "ECDH"
  },
  "c043": {
    "hash": "SHA384",
    "enc": "ARIA_256_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "c070": {
    "hash": "SHA256",
    "enc": "ARIA_128_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c071": {
    "hash": "SHA384",
    "enc": "ARIA_256_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c072": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_CBC",
    "sig": "ECDSA",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c073": {
    "hash": "SHA384",
    "enc": "CAMELLIA_256_CBC",
    "sig": "ECDSA",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c074": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_CBC",
    "sig": "ECDSA",
    "auth": "HMAC",
    "kex": "ECDH"
  },
  "c075": {
    "hash": "SHA384",
    "enc": "CAMELLIA_256_CBC",
    "sig": "ECDSA",
    "auth": "HMAC",
    "kex": "ECDH"
  },
  "c076": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c077": {
    "hash": "SHA384",
    "enc": "CAMELLIA_256_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "0040": {
    "hash": "SHA256",
    "enc": "AES_128_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "0041": {
    "hash": "SHA",
    "enc": "CAMELLIA_128_CBC",
    "sig": "RSA-KT",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "0042": {
    "hash": "SHA",
    "enc": "CAMELLIA_128_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DH"
  },
  "0043": {
    "hash": "SHA",
    "enc": "CAMELLIA_128_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DH"
  },
  "0044": {
    "hash": "SHA",
    "enc": "CAMELLIA_128_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "0045": {
    "hash": "SHA",
    "enc": "CAMELLIA_128_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "0046": {
    "hash": "SHA",
    "enc": "CAMELLIA_128_CBC",
    "sig": "anon",
    "auth": "HMAC",
    "kex": "DH_anon"
  },
  "c008": {
    "hash": "SHA",
    "enc": "3DES_EDE_CBC",
    "sig": "ECDSA",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c00e": {
    "hash": "SHA",
    "enc": "AES_128_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "ECDH"
  },
  "c00d": {
    "hash": "SHA",
    "enc": "3DES_EDE_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "ECDH"
  },
  "c00f": {
    "hash": "SHA",
    "enc": "AES_256_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "ECDH"
  },
  "c00a": {
    "hash": "SHA",
    "enc": "AES_256_CBC",
    "sig": "ECDSA",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c047": {
    "hash": "SHA384",
    "enc": "ARIA_256_CBC",
    "sig": "anon",
    "auth": "HMAC",
    "kex": "DH_anon"
  },
  "c00c": {
    "hash": "SHA",
    "enc": "RC4_128",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "ECDH"
  },
  "c00b": {
    "hash": "SHA",
    "enc": "NULL",
    "sig": "RSA",
    "auth": "NULL",
    "kex": "ECDH"
  },
  "003e": {
    "hash": "SHA256",
    "enc": "AES_128_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DH"
  },
  "003d": {
    "hash": "SHA256",
    "enc": "AES_256_CBC",
    "sig": "RSA-KT",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "003f": {
    "hash": "SHA256",
    "enc": "AES_128_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DH"
  },
  "003a": {
    "hash": "SHA",
    "enc": "AES_256_CBC",
    "sig": "anon",
    "auth": "HMAC",
    "kex": "DH_anon"
  },
  "003c": {
    "hash": "SHA256",
    "enc": "AES_128_CBC",
    "sig": "RSA-KT",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "003b": {
    "hash": "SHA256",
    "enc": "NULL",
    "sig": "RSA-KT",
    "auth": "NULL",
    "kex": "RSA"
  },
  "c028": {
    "hash": "SHA384",
    "enc": "AES_256_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c07a": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_GCM",
    "sig": "RSA-KT",
    "auth": "CAMELLIA_128_GCM",
    "kex": "RSA"
  },
  "00be": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "00ff": {
    "hash": "",
    "enc": "",
    "sig": "",
    "auth": "",
    "kex": ""
  },
  "c08e": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_GCM",
    "sig": "PSK",
    "auth": "CAMELLIA_128_GCM",
    "kex": "PSK"
  },
  "c08d": {
    "hash": "SHA384",
    "enc": "CAMELLIA_256_GCM",
    "sig": "RSA",
    "auth": "CAMELLIA_256_GCM",
    "kex": "ECDH"
  },
  "c08f": {
    "hash": "SHA384",
    "enc": "CAMELLIA_256_GCM",
    "sig": "PSK",
    "auth": "CAMELLIA_256_GCM",
    "kex": "PSK"
  },
  "c08a": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_GCM",
    "sig": "RSA",
    "auth": "CAMELLIA_128_GCM",
    "kex": "ECDHE"
  },
  "c08c": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_GCM",
    "sig": "RSA",
    "auth": "CAMELLIA_128_GCM",
    "kex": "ECDH"
  },
  "c08b": {
    "hash": "SHA384",
    "enc": "CAMELLIA_256_GCM",
    "sig": "RSA",
    "auth": "CAMELLIA_256_GCM",
    "kex": "ECDHE"
  },
  "c063": {
    "hash": "SHA384",
    "enc": "ARIA_256_GCM",
    "sig": "RSA",
    "auth": "ARIA_256_GCM",
    "kex": "ECDH"
  },
  "c062": {
    "hash": "SHA256",
    "enc": "ARIA_128_GCM",
    "sig": "RSA",
    "auth": "ARIA_128_GCM",
    "kex": "ECDH"
  },
  "c061": {
    "hash": "SHA384",
    "enc": "ARIA_256_GCM",
    "sig": "RSA",
    "auth": "ARIA_256_GCM",
    "kex": "ECDHE"
  },
  "c060": {
    "hash": "SHA256",
    "enc": "ARIA_128_GCM",
    "sig": "RSA",
    "auth": "ARIA_128_GCM",
    "kex": "ECDHE"
  },
  "c067": {
    "hash": "SHA384",
    "enc": "ARIA_256_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "DHE_PSK"
  },
  "c066": {
    "hash": "SHA256",
    "enc": "ARIA_128_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "DHE_PSK"
  },
  "c065": {
    "hash": "SHA384",
    "enc": "ARIA_256_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "PSK"
  },
  "c064": {
    "hash": "SHA256",
    "enc": "ARIA_128_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "PSK"
  },
  "c069": {
    "hash": "SHA384",
    "enc": "ARIA_256_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "c068": {
    "hash": "SHA256",
    "enc": "ARIA_128_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "c0a9": {
    "hash": "SHA",
    "enc": "AES_256_CCM_8",
    "sig": "PSK",
    "auth": "AES_256_CCM_8",
    "kex": "PSK"
  },
  "5600": {
    "hash": "",
    "enc": "",
    "sig": "",
    "auth": "",
    "kex": ""
  },
  "c05f": {
    "hash": "SHA384",
    "enc": "ARIA_256_GCM",
    "sig": "ECDSA",
    "auth": "ARIA_256_GCM",
    "kex": "ECDH"
  },
  "c0ac": {
    "hash": "SHA",
    "enc": "AES_128_CCM",
    "sig": "ECDSA",
    "auth": "AES_128_CCM",
    "kex": "ECDHE"
  },
  "c05d": {
    "hash": "SHA384",
    "enc": "ARIA_256_GCM",
    "sig": "ECDSA",
    "auth": "ARIA_256_GCM",
    "kex": "ECDHE"
  },
  "c05e": {
    "hash": "SHA256",
    "enc": "ARIA_128_GCM",
    "sig": "ECDSA",
    "auth": "ARIA_128_GCM",
    "kex": "ECDH"
  },
  "c05b": {
    "hash": "SHA384",
    "enc": "ARIA_256_GCM",
    "sig": "anon",
    "auth": "ARIA_256_GCM",
    "kex": "DH_anon"
  },
  "c05c": {
    "hash": "SHA256",
    "enc": "ARIA_128_GCM",
    "sig": "ECDSA",
    "auth": "ARIA_128_GCM",
    "kex": "ECDHE"
  },
  "c0ad": {
    "hash": "SHA",
    "enc": "AES_256_CCM",
    "sig": "ECDSA",
    "auth": "AES_256_CCM",
    "kex": "ECDHE"
  },
  "c05a": {
    "hash": "SHA256",
    "enc": "ARIA_128_GCM",
    "sig": "anon",
    "auth": "ARIA_128_GCM",
    "kex": "DH_anon"
  },
  "00af": {
    "hash": "SHA384",
    "enc": "AES_256_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "PSK"
  },
  "00ae": {
    "hash": "SHA256",
    "enc": "AES_128_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "PSK"
  },
  "00ad": {
    "hash": "SHA384",
    "enc": "AES_256_GCM",
    "sig": "PSK",
    "auth": "AES_256_GCM",
    "kex": "RSA"
  },
  "00ac": {
    "hash": "SHA256",
    "enc": "AES_128_GCM",
    "sig": "PSK",
    "auth": "AES_128_GCM",
    "kex": "RSA"
  },
  "00ab": {
    "hash": "SHA384",
    "enc": "AES_256_GCM",
    "sig": "PSK",
    "auth": "AES_256_GCM",
    "kex": "DHE_PSK"
  },
  "00aa": {
    "hash": "SHA256",
    "enc": "AES_128_GCM",
    "sig": "PSK",
    "auth": "AES_128_GCM",
    "kex": "DHE_PSK"
  },
  "c04b": {
    "hash": "SHA384",
    "enc": "ARIA_256_CBC",
    "sig": "ECDSA",
    "auth": "HMAC",
    "kex": "ECDH"
  },
  "c0a2": {
    "hash": "SHA",
    "enc": "AES_128_CCM_8",
    "sig": "RSA",
    "auth": "AES_128_CCM_8",
    "kex": "DHE"
  },
  "c0a3": {
    "hash": "SHA",
    "enc": "AES_256_CCM_8",
    "sig": "RSA",
    "auth": "AES_256_CCM_8",
    "kex": "DHE"
  },
  "c02e": {
    "hash": "SHA384",
    "enc": "AES_256_GCM",
    "sig": "ECDSA",
    "auth": "AES_256_GCM",
    "kex": "ECDH"
  },
  "c0a8": {
    "hash": "SHA",
    "enc": "AES_128_CCM_8",
    "sig": "PSK",
    "auth": "AES_128_CCM_8",
    "kex": "PSK"
  },
  "c02d": {
    "hash": "SHA256",
    "enc": "AES_128_GCM",
    "sig": "ECDSA",
    "auth": "AES_128_GCM",
    "kex": "ECDH"
  },
  "c0aa": {
    "hash": "SHA",
    "enc": "AES_128_CCM_8",
    "sig": "PSK",
    "auth": "AES_128_CCM_8",
    "kex": "DHE"
  },
  "c058": {
    "hash": "SHA256",
    "enc": "ARIA_128_GCM",
    "sig": "DSS",
    "auth": "ARIA_128_GCM",
    "kex": "DH"
  },
  "c059": {
    "hash": "SHA384",
    "enc": "ARIA_256_GCM",
    "sig": "DSS",
    "auth": "ARIA_256_GCM",
    "kex": "DH"
  },
  "c056": {
    "hash": "SHA256",
    "enc": "ARIA_128_GCM",
    "sig": "DSS",
    "auth": "ARIA_128_GCM",
    "kex": "DHE"
  },
  "c057": {
    "hash": "SHA384",
    "enc": "ARIA_256_GCM",
    "sig": "DSS",
    "auth": "ARIA_256_GCM",
    "kex": "DHE"
  },
  "c054": {
    "hash": "SHA256",
    "enc": "ARIA_128_GCM",
    "sig": "RSA",
    "auth": "ARIA_128_GCM",
    "kex": "DH"
  },
  "c055": {
    "hash": "SHA384",
    "enc": "ARIA_256_GCM",
    "sig": "RSA",
    "auth": "ARIA_256_GCM",
    "kex": "DH"
  },
  "c052": {
    "hash": "SHA256",
    "enc": "ARIA_128_GCM",
    "sig": "RSA",
    "auth": "ARIA_128_GCM",
    "kex": "DHE"
  },
  "c053": {
    "hash": "SHA384",
    "enc": "ARIA_256_GCM",
    "sig": "RSA",
    "auth": "ARIA_256_GCM",
    "kex": "DHE"
  },
  "c050": {
    "hash": "SHA256",
    "enc": "ARIA_128_GCM",
    "sig": "RSA-KT",
    "auth": "ARIA_128_GCM",
    "kex": "RSA"
  },
  "c051": {
    "hash": "SHA384",
    "enc": "ARIA_256_GCM",
    "sig": "RSA-KT",
    "auth": "ARIA_256_GCM",
    "kex": "RSA"
  },
  "c06c": {
    "hash": "SHA256",
    "enc": "ARIA_128_GCM",
    "sig": "PSK",
    "auth": "ARIA_128_GCM",
    "kex": "DHE_PSK"
  },
  "c06b": {
    "hash": "SHA384",
    "enc": "ARIA_256_GCM",
    "sig": "PSK",
    "auth": "ARIA_256_GCM",
    "kex": "PSK"
  },
  "c06a": {
    "hash": "SHA256",
    "enc": "ARIA_128_GCM",
    "sig": "PSK",
    "auth": "ARIA_128_GCM",
    "kex": "PSK"
  },
  "c06f": {
    "hash": "SHA384",
    "enc": "ARIA_256_GCM",
    "sig": "PSK",
    "auth": "ARIA_256_GCM",
    "kex": "RSA"
  },
  "c06e": {
    "hash": "SHA256",
    "enc": "ARIA_128_GCM",
    "sig": "PSK",
    "auth": "ARIA_128_GCM",
    "kex": "RSA"
  },
  "c06d": {
    "hash": "SHA384",
    "enc": "ARIA_256_GCM",
    "sig": "PSK",
    "auth": "ARIA_256_GCM",
    "kex": "DHE_PSK"
  },
  "c0a5": {
    "hash": "SHA",
    "enc": "AES_256_CCM",
    "sig": "PSK",
    "auth": "AES_256_CCM",
    "kex": "PSK"
  },
  "ccaa": {
    "hash": "SHA256",
    "enc": "CHACHA20_POLY1305",
    "sig": "RSA",
    "auth": "CHACHA20_POLY1305",
    "kex": "DHE"
  },
  "c018": {
    "hash": "SHA",
    "enc": "AES_128_CBC",
    "sig": "anon",
    "auth": "HMAC",
    "kex": "ECDH_anon"
  },
  "c0a1": {
    "hash": "SHA",
    "enc": "AES_256_CCM_8",
    "sig": "RSA-KT",
    "auth": "AES_256_CCM_8",
    "kex": "RSA"
  },
  "00a7": {
    "hash": "SHA384",
    "enc": "AES_256_GCM",
    "sig": "anon",
    "auth": "AES_256_GCM",
    "kex": "DH_anon"
  },
  "00a6": {
    "hash": "SHA256",
    "enc": "AES_128_GCM",
    "sig": "anon",
    "auth": "AES_128_GCM",
    "kex": "DH_anon"
  },
  "00a5": {
    "hash": "SHA384",
    "enc": "AES_256_GCM",
    "sig": "DSS",
    "auth": "AES_256_GCM",
    "kex": "DH"
  },
  "00a4": {
    "hash": "SHA256",
    "enc": "AES_128_GCM",
    "sig": "DSS",
    "auth": "AES_128_GCM",
    "kex": "DH"
  },
  "00a3": {
    "hash": "SHA384",
    "enc": "AES_256_GCM",
    "sig": "DSS",
    "auth": "AES_256_GCM",
    "kex": "DHE"
  },
  "00a2": {
    "hash": "SHA256",
    "enc": "AES_128_GCM",
    "sig": "DSS",
    "auth": "AES_128_GCM",
    "kex": "DHE"
  },
  "00a1": {
    "hash": "SHA384",
    "enc": "AES_256_GCM",
    "sig": "RSA",
    "auth": "AES_256_GCM",
    "kex": "DH"
  },
  "00a0": {
    "hash": "SHA256",
    "enc": "AES_128_GCM",
    "sig": "RSA",
    "auth": "AES_128_GCM",
    "kex": "DH"
  },
  "c098": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "00a9": {
    "hash": "SHA384",
    "enc": "AES_256_GCM",
    "sig": "PSK",
    "auth": "AES_256_GCM",
    "kex": "PSK"
  },
  "00a8": {
    "hash": "SHA256",
    "enc": "AES_128_GCM",
    "sig": "PSK",
    "auth": "AES_128_GCM",
    "kex": "PSK"
  },
  "c049": {
    "hash": "SHA384",
    "enc": "ARIA_256_CBC",
    "sig": "ECDSA",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c048": {
    "hash": "SHA256",
    "enc": "ARIA_128_CBC",
    "sig": "ECDSA",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c0ab": {
    "hash": "SHA",
    "enc": "AES_256_CCM_8",
    "sig": "PSK",
    "auth": "AES_256_CCM_8",
    "kex": "DHE"
  },
  "cca8": {
    "hash": "SHA256",
    "enc": "CHACHA20_POLY1305",
    "sig": "RSA",
    "auth": "CHACHA20_POLY1305",
    "kex": "ECDHE"
  },
  "c03d": {
    "hash": "SHA384",
    "enc": "ARIA_256_CBC",
    "sig": "RSA-KT",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "c03e": {
    "hash": "SHA256",
    "enc": "ARIA_128_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DH"
  },
  "c03f": {
    "hash": "SHA384",
    "enc": "ARIA_256_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DH"
  },
  "c042": {
    "hash": "SHA256",
    "enc": "ARIA_128_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "c045": {
    "hash": "SHA384",
    "enc": "ARIA_256_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "c03a": {
    "hash": "SHA256",
    "enc": "NULL",
    "sig": "PSK",
    "auth": "NULL",
    "kex": "ECDHE"
  },
  "c03b": {
    "hash": "SHA384",
    "enc": "NULL",
    "sig": "PSK",
    "auth": "NULL",
    "kex": "ECDHE"
  },
  "c03c": {
    "hash": "SHA256",
    "enc": "ARIA_128_CBC",
    "sig": "RSA-KT",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "000d": {
    "hash": "SHA",
    "enc": "3DES_EDE_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DH"
  },
  "000e": {
    "hash": "SHA",
    "enc": "DES40_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DH"
  },
  "000f": {
    "hash": "SHA",
    "enc": "DES_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DH"
  },
  "000a": {
    "hash": "SHA",
    "enc": "3DES_EDE_CBC",
    "sig": "RSA-KT",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "000b": {
    "hash": "SHA",
    "enc": "DES40_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DH"
  },
  "000c": {
    "hash": "SHA",
    "enc": "DES_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DH"
  },
  "c082": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_GCM",
    "sig": "DSS",
    "auth": "CAMELLIA_128_GCM",
    "kex": "DH"
  },
  "c0ae": {
    "hash": "SHA",
    "enc": "AES_128_CCM_8",
    "sig": "ECDSA",
    "auth": "AES_128_CCM_8",
    "kex": "ECDHE"
  },
  "ccac": {
    "hash": "SHA256",
    "enc": "CHACHA20_POLY1305",
    "sig": "PSK",
    "auth": "CHACHA20_POLY1305",
    "kex": "ECDHE"
  },
  "c009": {
    "hash": "SHA",
    "enc": "AES_128_CBC",
    "sig": "ECDSA",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "ccab": {
    "hash": "SHA256",
    "enc": "CHACHA20_POLY1305",
    "sig": "PSK",
    "auth": "CHACHA20_POLY1305",
    "kex": "PSK"
  },
  "c029": {
    "hash": "SHA256",
    "enc": "AES_128_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "ECDH"
  },
  "00b3": {
    "hash": "SHA384",
    "enc": "AES_256_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "DHE_PSK"
  },
  "ccae": {
    "hash": "SHA256",
    "enc": "CHACHA20_POLY1305",
    "sig": "PSK",
    "auth": "CHACHA20_POLY1305",
    "kex": "RSA"
  },
  "ccad": {
    "hash": "SHA256",
    "enc": "CHACHA20_POLY1305",
    "sig": "PSK",
    "auth": "CHACHA20_POLY1305",
    "kex": "DHE_PSK"
  },
  "00b2": {
    "hash": "SHA256",
    "enc": "AES_128_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "DHE_PSK"
  },
  "0067": {
    "hash": "SHA256",
    "enc": "AES_128_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "00b0": {
    "hash": "SHA256",
    "enc": "NULL",
    "sig": "PSK",
    "auth": "NULL",
    "kex": "PSK"
  },
  "00b1": {
    "hash": "SHA384",
    "enc": "NULL",
    "sig": "PSK",
    "auth": "NULL",
    "kex": "PSK"
  },
  "00b6": {
    "hash": "SHA256",
    "enc": "AES_128_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "00b7": {
    "hash": "SHA384",
    "enc": "AES_256_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "00b4": {
    "hash": "SHA256",
    "enc": "NULL",
    "sig": "PSK",
    "auth": "NULL",
    "kex": "DHE_PSK"
  },
  "00b5": {
    "hash": "SHA384",
    "enc": "NULL",
    "sig": "PSK",
    "auth": "NULL",
    "kex": "DHE_PSK"
  },
  "00b8": {
    "hash": "SHA256",
    "enc": "NULL",
    "sig": "PSK",
    "auth": "NULL",
    "kex": "RSA"
  },
  "00b9": {
    "hash": "SHA384",
    "enc": "NULL",
    "sig": "PSK",
    "auth": "NULL",
    "kex": "RSA"
  },
  "c0af": {
    "hash": "SHA",
    "enc": "AES_256_CCM_8",
    "sig": "ECDSA",
    "auth": "AES_256_CCM_8",
    "kex": "ECDHE"
  },
  "0068": {
    "hash": "SHA256",
    "enc": "AES_256_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DH"
  },
  "0069": {
    "hash": "SHA256",
    "enc": "AES_256_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DH"
  },
  "0004": {
    "hash": "MD5",
    "enc": "RC4_128",
    "sig": "RSA-KT",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "0005": {
    "hash": "SHA",
    "enc": "RC4_128",
    "sig": "RSA-KT",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "0006": {
    "hash": "MD5",
    "enc": "RC2_CBC_40",
    "sig": "RSA-KT",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "0007": {
    "hash": "SHA",
    "enc": "IDEA_CBC",
    "sig": "RSA-KT",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "0000": {
    "hash": "NULL",
    "enc": "NULL",
    "sig": "NULL",
    "auth": "NULL",
    "kex": "NULL"
  },
  "0001": {
    "hash": "MD5",
    "enc": "NULL",
    "sig": "RSA-KT",
    "auth": "NULL",
    "kex": "RSA"
  },
  "0002": {
    "hash": "SHA",
    "enc": "NULL",
    "sig": "RSA-KT",
    "auth": "NULL",
    "kex": "RSA"
  },
  "0003": {
    "hash": "MD5",
    "enc": "RC4_40",
    "sig": "RSA-KT",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "00bf": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_CBC",
    "sig": "anon",
    "auth": "HMAC",
    "kex": "DH_anon"
  },
  "0008": {
    "hash": "SHA",
    "enc": "DES40_CBC",
    "sig": "RSA-KT",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "0009": {
    "hash": "SHA",
    "enc": "DES_CBC",
    "sig": "RSA-KT",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "c09e": {
    "hash": "SHA",
    "enc": "AES_128_CCM",
    "sig": "RSA",
    "auth": "AES_128_CCM",
    "kex": "DHE"
  },
  "c038": {
    "hash": "SHA384",
    "enc": "AES_256_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c01d": {
    "hash": "SHA",
    "enc": "AES_128_CBC",
    "sig": "SRP_SHA",
    "auth": "HMAC",
    "kex": "SRP_SHA"
  },
  "c034": {
    "hash": "SHA",
    "enc": "3DES_EDE_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c035": {
    "hash": "SHA",
    "enc": "AES_128_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c036": {
    "hash": "SHA",
    "enc": "AES_256_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c01e": {
    "hash": "SHA",
    "enc": "AES_128_CBC",
    "sig": "SRP_SHA_RSA",
    "auth": "HMAC",
    "kex": "SRP_SHA_RSA"
  },
  "c030": {
    "hash": "SHA384",
    "enc": "AES_256_GCM",
    "sig": "RSA",
    "auth": "AES_256_GCM",
    "kex": "ECDHE"
  },
  "c031": {
    "hash": "SHA256",
    "enc": "AES_128_GCM",
    "sig": "RSA",
    "auth": "AES_128_GCM",
    "kex": "ECDH"
  },
  "c032": {
    "hash": "SHA384",
    "enc": "AES_256_GCM",
    "sig": "RSA",
    "auth": "AES_256_GCM",
    "kex": "ECDH"
  },
  "c033": {
    "hash": "SHA",
    "enc": "RC4_128",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "00bb": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DH"
  },
  "00bc": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DH"
  },
  "006d": {
    "hash": "SHA256",
    "enc": "AES_256_CBC",
    "sig": "anon",
    "auth": "HMAC",
    "kex": "DH_anon"
  },
  "00ba": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_CBC",
    "sig": "RSA-KT",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "006b": {
    "hash": "SHA256",
    "enc": "AES_256_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "006c": {
    "hash": "SHA256",
    "enc": "AES_128_CBC",
    "sig": "anon",
    "auth": "HMAC",
    "kex": "DH_anon"
  },
  "00bd": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "006a": {
    "hash": "SHA256",
    "enc": "AES_256_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "c096": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "DHE_PSK"
  },
  "c039": {
    "hash": "SHA",
    "enc": "NULL",
    "sig": "PSK",
    "auth": "NULL",
    "kex": "ECDHE"
  },
  "00c5": {
    "hash": "SHA256",
    "enc": "CAMELLIA_256_CBC",
    "sig": "anon",
    "auth": "HMAC",
    "kex": "DH_anon"
  },
  "00c4": {
    "hash": "SHA256",
    "enc": "CAMELLIA_256_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "00c1": {
    "hash": "SHA256",
    "enc": "CAMELLIA_256_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DH"
  },
  "00c0": {
    "hash": "SHA256",
    "enc": "CAMELLIA_256_CBC",
    "sig": "RSA-KT",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "00c3": {
    "hash": "SHA256",
    "enc": "CAMELLIA_256_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "00c2": {
    "hash": "SHA256",
    "enc": "CAMELLIA_256_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DH"
  },
  "0017": {
    "hash": "MD5",
    "enc": "RC4_40",
    "sig": "anon",
    "auth": "HMAC",
    "kex": "DH_anon"
  },
  "0016": {
    "hash": "SHA",
    "enc": "3DES_EDE_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "0015": {
    "hash": "SHA",
    "enc": "DES_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "0014": {
    "hash": "SHA",
    "enc": "DES40_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "0013": {
    "hash": "SHA",
    "enc": "3DES_EDE_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "0012": {
    "hash": "SHA",
    "enc": "DES_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "0011": {
    "hash": "SHA",
    "enc": "DES40_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "0010": {
    "hash": "SHA",
    "enc": "3DES_EDE_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DH"
  },
  "c01b": {
    "hash": "SHA",
    "enc": "3DES_EDE_CBC",
    "sig": "SRP_SHA_RSA",
    "auth": "HMAC",
    "kex": "SRP_SHA_RSA"
  },
  "c01c": {
    "hash": "SHA",
    "enc": "3DES_EDE_CBC",
    "sig": "SRP_SHA_RSA",
    "auth": "HMAC",
    "kex": "SRP_SHA_RSA"
  },
  "c01a": {
    "hash": "SHA",
    "enc": "3DES_EDE_CBC",
    "sig": "SRP_SHA",
    "auth": "HMAC",
    "kex": "SRP_SHA"
  },
  "c01f": {
    "hash": "SHA",
    "enc": "AES_128_CBC",
    "sig": "SRP_SHA_RSA",
    "auth": "HMAC",
    "kex": "SRP_SHA_RSA"
  },
  "0019": {
    "hash": "SHA",
    "enc": "DES40_CBC",
    "sig": "anon",
    "auth": "HMAC",
    "kex": "DH_anon"
  },
  "0018": {
    "hash": "MD5",
    "enc": "RC4_128",
    "sig": "anon",
    "auth": "HMAC",
    "kex": "DH_anon"
  },
  "002b": {
    "hash": "MD5",
    "enc": "RC4_40",
    "sig": "KRB5",
    "auth": "HMAC",
    "kex": "KRB5"
  },
  "002c": {
    "hash": "SHA",
    "enc": "NULL",
    "sig": "PSK",
    "auth": "NULL",
    "kex": "PSK"
  },
  "002a": {
    "hash": "MD5",
    "enc": "RC2_CBC_40",
    "sig": "KRB5",
    "auth": "HMAC",
    "kex": "KRB5"
  },
  "002f": {
    "hash": "SHA",
    "enc": "AES_128_CBC",
    "sig": "RSA-KT",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "002d": {
    "hash": "SHA",
    "enc": "NULL",
    "sig": "PSK",
    "auth": "NULL",
    "kex": "DHE_PSK"
  },
  "002e": {
    "hash": "SHA",
    "enc": "NULL",
    "sig": "PSK",
    "auth": "NULL",
    "kex": "RSA"
  },
  "c027": {
    "hash": "SHA256",
    "enc": "AES_128_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c026": {
    "hash": "SHA384",
    "enc": "AES_256_CBC",
    "sig": "ECDSA",
    "auth": "HMAC",
    "kex": "ECDH"
  },
  "c025": {
    "hash": "SHA256",
    "enc": "AES_128_CBC",
    "sig": "ECDSA",
    "auth": "HMAC",
    "kex": "ECDH"
  },
  "c024": {
    "hash": "SHA384",
    "enc": "AES_256_CBC",
    "sig": "ECDSA",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c023": {
    "hash": "SHA256",
    "enc": "AES_128_CBC",
    "sig": "ECDSA",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c022": {
    "hash": "SHA",
    "enc": "AES_256_CBC",
    "sig": "SRP_SHA_RSA",
    "auth": "HMAC",
    "kex": "SRP_SHA_RSA"
  },
  "c021": {
    "hash": "SHA",
    "enc": "AES_256_CBC",
    "sig": "SRP_SHA_RSA",
    "auth": "HMAC",
    "kex": "SRP_SHA_RSA"
  },
  "c020": {
    "hash": "SHA",
    "enc": "AES_256_CBC",
    "sig": "SRP_SHA",
    "auth": "HMAC",
    "kex": "SRP_SHA"
  },
  "c046": {
    "hash": "SHA256",
    "enc": "ARIA_128_CBC",
    "sig": "anon",
    "auth": "HMAC",
    "kex": "DH_anon"
  },
  "c0a0": {
    "hash": "SHA",
    "enc": "AES_128_CCM_8",
    "sig": "RSA-KT",
    "auth": "AES_128_CCM_8",
    "kex": "RSA"
  },
  "009f": {
    "hash": "SHA384",
    "enc": "AES_256_GCM",
    "sig": "RSA",
    "auth": "AES_256_GCM",
    "kex": "DHE"
  },
  "009e": {
    "hash": "SHA256",
    "enc": "AES_128_GCM",
    "sig": "RSA",
    "auth": "AES_128_GCM",
    "kex": "DHE"
  },
  "009d": {
    "hash": "SHA384",
    "enc": "AES_256_GCM",
    "sig": "RSA-KT",
    "auth": "AES_256_GCM",
    "kex": "RSA"
  },
  "009c": {
    "hash": "SHA256",
    "enc": "AES_128_GCM",
    "sig": "RSA-KT",
    "auth": "AES_128_GCM",
    "kex": "RSA"
  },
  "009b": {
    "hash": "SHA",
    "enc": "SEED_CBC",
    "sig": "anon",
    "auth": "HMAC",
    "kex": "DH_anon"
  },
  "009a": {
    "hash": "SHA",
    "enc": "SEED_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "c09b": {
    "hash": "SHA384",
    "enc": "CAMELLIA_256_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c078": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "ECDH"
  },
  "c09a": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "0088": {
    "hash": "SHA",
    "enc": "CAMELLIA_256_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "0089": {
    "hash": "SHA",
    "enc": "CAMELLIA_256_CBC",
    "sig": "anon",
    "auth": "HMAC",
    "kex": "DH_anon"
  },
  "c09d": {
    "hash": "SHA",
    "enc": "AES_256_CCM",
    "sig": "RSA-KT",
    "auth": "AES_256_CCM",
    "kex": "RSA"
  },
  "c079": {
    "hash": "SHA384",
    "enc": "CAMELLIA_256_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "ECDH"
  },
  "0084": {
    "hash": "SHA",
    "enc": "CAMELLIA_256_CBC",
    "sig": "RSA-KT",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "0085": {
    "hash": "SHA",
    "enc": "CAMELLIA_256_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DH"
  },
  "0086": {
    "hash": "SHA",
    "enc": "CAMELLIA_256_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DH"
  },
  "0087": {
    "hash": "SHA",
    "enc": "CAMELLIA_256_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "c0a6": {
    "hash": "SHA",
    "enc": "AES_128_CCM",
    "sig": "PSK",
    "auth": "AES_128_CCM",
    "kex": "DHE_PSK"
  },
  "0022": {
    "hash": "MD5",
    "enc": "DES_CBC",
    "sig": "KRB5",
    "auth": "HMAC",
    "kex": "KRB5"
  },
  "0023": {
    "hash": "MD5",
    "enc": "3DES_EDE_CBC",
    "sig": "KRB5",
    "auth": "HMAC",
    "kex": "KRB5"
  },
  "0020": {
    "hash": "SHA",
    "enc": "RC4_128",
    "sig": "KRB5",
    "auth": "HMAC",
    "kex": "KRB5"
  },
  "0021": {
    "hash": "SHA",
    "enc": "IDEA_CBC",
    "sig": "KRB5",
    "auth": "HMAC",
    "kex": "KRB5"
  },
  "0026": {
    "hash": "SHA",
    "enc": "DES40_CBC",
    "sig": "KRB5",
    "auth": "HMAC",
    "kex": "KRB5"
  },
  "0027": {
    "hash": "SHA",
    "enc": "RC2_CBC_40",
    "sig": "KRB5",
    "auth": "HMAC",
    "kex": "KRB5"
  },
  "0024": {
    "hash": "MD5",
    "enc": "RC4_128",
    "sig": "KRB5",
    "auth": "HMAC",
    "kex": "KRB5"
  },
  "0025": {
    "hash": "MD5",
    "enc": "IDEA_CBC",
    "sig": "KRB5",
    "auth": "HMAC",
    "kex": "KRB5"
  },
  "c02f": {
    "hash": "SHA256",
    "enc": "AES_128_GCM",
    "sig": "RSA",
    "auth": "AES_128_GCM",
    "kex": "ECDHE"
  },
  "0028": {
    "hash": "SHA",
    "enc": "RC4_40",
    "sig": "KRB5",
    "auth": "HMAC",
    "kex": "KRB5"
  },
  "0029": {
    "hash": "MD5",
    "enc": "DES40_CBC",
    "sig": "KRB5",
    "auth": "HMAC",
    "kex": "KRB5"
  },
  "c02c": {
    "hash": "SHA384",
    "enc": "AES_256_GCM",
    "sig": "ECDSA",
    "auth": "AES_256_GCM",
    "kex": "ECDHE"
  },
  "c02b": {
    "hash": "SHA256",
    "enc": "AES_128_GCM",
    "sig": "ECDSA",
    "auth": "AES_128_GCM",
    "kex": "ECDHE"
  },
  "c02a": {
    "hash": "SHA384",
    "enc": "AES_256_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "ECDH"
  },
  "001f": {
    "hash": "SHA",
    "enc": "3DES_EDE_CBC",
    "sig": "KRB5",
    "auth": "HMAC",
    "kex": "KRB5"
  },
  "001e": {
    "hash": "SHA",
    "enc": "DES_CBC",
    "sig": "KRB5",
    "auth": "HMAC",
    "kex": "KRB5"
  },
  "c019": {
    "hash": "SHA",
    "enc": "AES_256_CBC",
    "sig": "anon",
    "auth": "HMAC",
    "kex": "ECDH_anon"
  },
  "001b": {
    "hash": "SHA",
    "enc": "3DES_EDE_CBC",
    "sig": "anon",
    "auth": "HMAC",
    "kex": "DH_anon"
  },
  "001a": {
    "hash": "SHA",
    "enc": "DES_CBC",
    "sig": "anon",
    "auth": "HMAC",
    "kex": "DH_anon"
  },
  "c012": {
    "hash": "SHA",
    "enc": "3DES_EDE_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c013": {
    "hash": "SHA",
    "enc": "AES_128_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c010": {
    "hash": "SHA",
    "enc": "NULL",
    "sig": "RSA",
    "auth": "NULL",
    "kex": "ECDHE"
  },
  "c011": {
    "hash": "SHA",
    "enc": "RC4_128",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c016": {
    "hash": "SHA",
    "enc": "RC4_128",
    "sig": "anon",
    "auth": "HMAC",
    "kex": "ECDH_anon"
  },
  "c017": {
    "hash": "SHA",
    "enc": "3DES_EDE_CBC",
    "sig": "anon",
    "auth": "HMAC",
    "kex": "ECDH_anon"
  },
  "c014": {
    "hash": "SHA",
    "enc": "AES_256_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "ECDHE"
  },
  "c015": {
    "hash": "SHA",
    "enc": "NULL",
    "sig": "anon",
    "auth": "NULL",
    "kex": "ECDH_anon"
  },
  "c092": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_GCM",
    "sig": "PSK",
    "auth": "CAMELLIA_128_GCM",
    "kex": "RSA"
  },
  "c093": {
    "hash": "SHA384",
    "enc": "CAMELLIA_256_GCM",
    "sig": "PSK",
    "auth": "CAMELLIA_256_GCM",
    "kex": "RSA"
  },
  "c090": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_GCM",
    "sig": "PSK",
    "auth": "CAMELLIA_128_GCM",
    "kex": "DHE_PSK"
  },
  "c091": {
    "hash": "SHA384",
    "enc": "CAMELLIA_256_GCM",
    "sig": "PSK",
    "auth": "CAMELLIA_256_GCM",
    "kex": "DHE_PSK"
  },
  "c044": {
    "hash": "SHA256",
    "enc": "ARIA_128_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "c097": {
    "hash": "SHA384",
    "enc": "CAMELLIA_256_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "DHE_PSK"
  },
  "c094": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "PSK"
  },
  "c095": {
    "hash": "SHA384",
    "enc": "CAMELLIA_256_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "PSK"
  },
  "008d": {
    "hash": "SHA",
    "enc": "AES_256_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "PSK"
  },
  "008e": {
    "hash": "SHA",
    "enc": "RC4_128",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "DHE_PSK"
  },
  "008f": {
    "hash": "SHA",
    "enc": "3DES_EDE_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "DHE_PSK"
  },
  "c099": {
    "hash": "SHA384",
    "enc": "CAMELLIA_256_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "008a": {
    "hash": "SHA",
    "enc": "RC4_128",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "PSK"
  },
  "008b": {
    "hash": "SHA",
    "enc": "3DES_EDE_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "PSK"
  },
  "008c": {
    "hash": "SHA",
    "enc": "AES_128_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "PSK"
  },
  "c084": {
    "hash": "SHA256",
    "enc": "CAMELLIA_128_GCM",
    "sig": "anon",
    "auth": "CAMELLIA_128_GCM",
    "kex": "DH_anon"
  },
  "0099": {
    "hash": "SHA",
    "enc": "SEED_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DHE"
  },
  "0098": {
    "hash": "SHA",
    "enc": "SEED_CBC",
    "sig": "RSA",
    "auth": "HMAC",
    "kex": "DH"
  },
  "0097": {
    "hash": "SHA",
    "enc": "SEED_CBC",
    "sig": "DSS",
    "auth": "HMAC",
    "kex": "DH"
  },
  "0096": {
    "hash": "SHA",
    "enc": "SEED_CBC",
    "sig": "RSA-KT",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "0095": {
    "hash": "SHA",
    "enc": "AES_256_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "0094": {
    "hash": "SHA",
    "enc": "AES_128_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "0093": {
    "hash": "SHA",
    "enc": "3DES_EDE_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "0092": {
    "hash": "SHA",
    "enc": "RC4_128",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "RSA"
  },
  "0091": {
    "hash": "SHA",
    "enc": "AES_256_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "DHE_PSK"
  },
  "0090": {
    "hash": "SHA",
    "enc": "AES_128_CBC",
    "sig": "PSK",
    "auth": "HMAC",
    "kex": "DHE_PSK"
  }
}

# A security_category object is one of { recommended, acceptable,
# legacy, avoid }
#

UNKNOWN = 0
INVALID = 1
VALID   = 2

security_categories = { 
    "unknown": 0,
    "avoid": 1,
    "legacy": 2,
    "acceptable": 3,
    "reccomended": 4, 
    }

seclevel_names = {v: k for k, v in security_categories.iteritems()}

def seclevel(x):
    if x in seclevel_names:
        return seclevel_names[x]
    if x in security_categories:
        return security_categories[x]
    return 0

# A hash/enc/kex/sig/auth *_policy object maps a crypto mechanism to a
# security_category
#
hash_policy = {
    "SHA": 2,
    "NULL": 1,
    "SHA256": 4,
    "SHA384": 4,
    "MD5": 1
    }

enc_policy = {
    "ARIA_128_GCM": 3,
    "DES_CBC": 1,
    "ARIA_128_CBC": 3,
    "CAMELLIA_256_GCM": 3,
    "AES_128_CCM": 4,
    "CAMELLIA_128_GCM": 3,
    "3DES_EDE_CBC": 2,
    "DES40_CBC": 1,
    "ARIA_256_GCM": 3,
    "SEED_CBC": 2,
    "RC4_128": 1,
    "NULL": 1,
    "CAMELLIA_256_CBC": 3,
    "ARIA_256_CBC": 3,
    "RC4_40": 1,
    "RC2_CBC_40": 1,
    "AES_256_GCM": 4,
    "IDEA_CBC": 1,
    "AES_128_CCM_8": 3,
    "AES_128_CBC": 3,
    "AES_256_CCM": 3,
    "CHACHA20_POLY1305": 3,
    "AES_256_CBC": 3,
    "AES_128_GCM": 3,
    "CAMELLIA_128_CBC": 3,
    "AES_256_CCM_8": 3
    }

sig_policy =  {
    "KRB5": 3,
    "PSK": 2,
    "SRP_SHA": 2,
    "RSA-KT": 3,
    "DSS": 2,
    "SRP_SHA_RSA": 2,
    "RSA": 3,
    "anon": 1,
    "NULL": 1,
    "ECDSA": 4
    }

auth_policy = {
    "AES_256_GCM": 4,
    "NULL": 1,
    "AES_256_CCM": 3,
    "CHACHA20_POLY1305": 3,
    "AES_128_CCM_8": 3,
    "ARIA_128_GCM": 3,
    "AES_256_CCM_8": 3,
    "CAMELLIA_256_GCM": 3,
    "AES_128_CCM": 3,
    "CAMELLIA_128_GCM": 3,
    "AES_128_GCM": 4,
    "ARIA_256_GCM": 3,
    "HMAC": 3
    }

kex_policy = {
    "KRB5": 3,
    "PSK": 2,
    "DH": 2,
    "SRP_SHA": 2,
    "ECDH_anon": 1,
    "DHE": 3,
    "ECDH": 3,
    "RSA": 3,
    "SRP_SHA_RSA": 2,
    "ECDHE": 4,
    "DHE_PSK": 3,
    "NULL": 1,
    "DH_anon": 1
  }

sig_alg_policy = {
   "sha1WithRSAEncryption": 1,
   "sha256WithRSAEncryption": 3,
   "sha384WithRSAEncryption": 3,
   "sha512WithRSAEncryption": 4,
   "ecdsa-with-SHA256": 3
}

def tls_seclevel(scs, client_key_length, certs):
    if not scs:
        return 'unknown'
    else:
        params = tls_params[scs]

        kex = params['kex']
        if kex == "RSA" or kex == "DH" or kex == "DHE_anon" or kex == "DHE_PSK" or kex == "SRP_SHA" or kex == "SRP_SHA_RSA":
            if client_key_length < 1024:
                kex_seclevel = 1 # avoid
            elif client_key_length < 2048:
                kex_seclevel = 2 # legacy
            elif client_key_length < 3072:
                kex_seclevel = 3 # acceptable
            else:
                kex_seclevel = 4 # reccommended

        elif kex == "ECDHE" or kex == "ECDH" or kex == "ECDH_anon":
            if client_key_length < 224:
                kex_seclevel = 1 # avoid
            elif client_key_length < 256:
                kex_seclevel = 2 # legacy
            elif client_key_length < 512:
                kex_seclevel = 3 # acceptable
            else:
                kex_seclevel = 4 # recommended            
        else:
            kex_seclevel = kex_policy[kex]

        if certs:
           certs_seclevel = 4
           for x in certs:
              sig_alg = x['signature_algorithm']
              sig_key_size = x['signature_key_size']
              if sig_alg == "sha1WithRSAEncryption": 
                 if sig_key_size < 1024:
                    tmp_seclevel = 1 
                 else:
                    tmp_seclevel = 2
              elif sig_alg == "sha256WithRSAEncryption": 
                 if sig_key_size < 1024:
                    tmp_seclevel = 1 
                 elif sig_key_size < 2048:
                    tmp_seclevel = 2
                 else:
                    tmp_seclevel = 3 
              elif sig_alg == "ecdsa-with-SHA256":
                 if sig_key_size < 832:
                    tmp_seclevel = 1 
                 else:
                    tmp_seclevel = 3
              elif sig_alg == "sha384WithRSAEncryption" or sig_alg == "sha512WithRSAEncryption": 
                 if sig_key_size < 1024:
                    tmp_seclevel = 1 
                 elif sig_key_size < 2048:
                    tmp_seclevel = 2
                 elif sig_key_size < 3072:
                    tmp_seclevel = 3
                 else:
                    tmp_seclevel = 4
              else:
                 tmp_seclevel = 0
              if tmp_seclevel < certs_seclevel: 
                 certs_seclevel = tmp_seclevel
        else:
           certs_seclevel = 0

        return seclevel(min(kex_seclevel, 
                            certs_seclevel,
                            sig_policy[params['sig']],
                            enc_policy[params['enc']],
                            auth_policy[params['auth']],
                            hash_policy[params['hash']]))


def tlsEnrich(flow):
   if 'tls' not in flow:
      return None
   else:
      # get security-relevant parameters from flow record
      #
      tls = flow['tls']
      if 'tls_client_key_length' in tls:
         client_key_length = tls['tls_client_key_length'] - 16 # subtract 16 encoding bits
      else:
         client_key_length = None
      if 's_tls_ext' in tls:
         server_extensions = tls['s_tls_ext']
      else:
         server_extensions = None
      if 'scs' in tls:
         scs = tls['scs']
      else:
         scs = None

      if 'server_cert' in tls:
         certs = list()
         for x in tls['server_cert']:
            tmp = dict()
            tmp['signature_algorithm'] = x['signature_algorithm']
            tmp['signature_key_size'] = x['signature_key_size']
            certs.append(tmp)
      else:
         certs = None

      # evaluate seclevel based on parameters
      #
      return tls_seclevel(scs, client_key_length, certs)

# main processing pipeline
#
def pipeline():

   # process_commands(sys.argv)         
   #exit()

   parser = OptionParser()
   parser.set_description("filter JSON flow data and print out matching flows, selected fields, or stats")
   # parser.add_option("--from",  dest="inputfile", help="JSON input file")
   parser.add_option("--where",  dest="filter", help="filter flows")
   parser.add_option("--select", dest="selection", help="select field to output")
   parser.add_option("--split",  dest="splitfield", help="split processing by field")
   parser.add_option("--dist",   action="store_true", help="compute distribution over selected element(s)")
   parser.add_option("--stitch", action="store_true", help="stitch together successive flows separated by active timeouts")
   parser.add_option("--pretty", action="store_true", help="pretty-print JSON output")
   parser.add_option("--sum",    dest="sumvars", help="compute sum over selected element(s)")
   parser.add_option("--seclevel", action="store_true", help="report security level of TLS sessions")

   # parse command line, and check arguments
   (opts, args) = parser.parse_args()
   if not args:
      args.append('-')   # no input files, so assume stdin 

   if opts.pretty:
      json_indent = 3
   else:
      json_indent = None

   # set flow processor
   #
   if opts.selection is not None:
      fp = flowElementSelector(opts.selection)
   else:
      fp = flowProcessor()      
   if opts.splitfield:
      fp = splitProcessor(fp, opts.splitfield)

   # set post-processor
   #
   if opts.dist:
      postproc = flowProcessorDistribution()
   elif opts.sumvars:
      postproc = flowProcessorSum(opts.sumvars,indent=json_indent)
   else:
      postproc = flowProcessor(indent=json_indent)

   # process all files, with pre- and post-processing
   #
   fp.preProcess()
   for x in args:

      # set flow source
      #
      flowSource = flowIteratorFromFile(x)
      if opts.stitch:
         flowSource = flowStitchIterator(flowSource)
      if opts.filter:
         flowSource = flowFilterIterator(flowSource, flowPredicate(opts.filter))
      if opts.seclevel:
         flowSource = flowEnrichIterator(flowSource, "seclevel", tlsEnrich)

      # process all flows from source
      try:
         for flow in flowSource:
            fp.processFlow(flow)
      except KeyboardInterrupt:
         sys.exit()
      except:
         raise
   fp.postProcess(postproc)


#
# main function 
#
if __name__=='__main__':
   pipeline()
